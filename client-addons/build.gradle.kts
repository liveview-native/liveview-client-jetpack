plugins {
    alias(libs.plugins.android.library)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.roborazzi)
}

val moduleId = "org.phoenixframework.liveview.addons"
android {
    namespace = moduleId
    compileSdk = Constants.compileSdkVersion

    defaultConfig {
        minSdk = Constants.minSdkVersion

        testApplicationId = "$moduleId.test"
        testInstrumentationRunner = Constants.instrumentationRunnerClass
        consumerProguardFiles("consumer-rules.pro")
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = Constants.sourceCompatibilityVersion
        targetCompatibility = Constants.targetCompatibilityVersion
    }
    kotlinOptions {
        jvmTarget = Constants.jvmTargetVersion
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = Constants.kotlinCompilerExtVersion
    }

    testNamespace = "$moduleId.test"
    testOptions.unitTests.isIncludeAndroidResources = true
}

dependencies {
    implementation(project(":client"))
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.compose.ui)
    implementation(libs.androidx.compose.material3)

    implementation(platform(libs.koin.bom))
    implementation(libs.koin.core)
    implementation(libs.koin.android)
    implementation(libs.koin.compose)

    implementation(libs.io.coil.kt)
    implementation(libs.io.coil.kt.coil.compose)
    implementation(libs.io.coil.kt.coil.svg)

    // Test dependencies
    testImplementation(libs.junit)
    testImplementation(libs.androidx.test.ext.junit)
    testImplementation(libs.androidx.compose.ui.test.junit4.android)

    testImplementation(libs.io.coil.kt.coil.test)
    testImplementation(libs.io.github.takahirom.roborazzi)
    testImplementation(libs.io.github.takahirom.roborazzi.compose)
    testImplementation(libs.io.github.takahirom.roborazzi.junit.rule)
    testImplementation(libs.koin.test)
    testImplementation(libs.org.robolectric)
}

// TODO The Core-Jetpack project only generates the native platform library files for the
//  following architectures (arm, arm64, x86, and x86_64). In order to run the tests in the local
//  machine, we need the library for the host machine. For now, this file is being generated by
//  adding the "darwin-aarch64" (or "darwin-x86-64" for Intel Macbooks) target, and running the
//  following command in the Core-Jetpack project: `./gradlew assembleRelease`.
//  The library files are generated at "core/build/rustJniLibs/desktop" directory. The ideal
//  solution is release a dependency just for unit tests and declare at the `dependencies` section
//  above like:
//  `testImplementation "com.github.liveview-native:liveview-native-core-jetpack-host:<version>"`
// Configuring Java Lib Path in order to find the native library before running the Unit Tests
tasks.withType<Test>().configureEach {
    doFirst {
        val jniLibsForDesktopDir = File("${rootDir}/client/src/test/jniLibs")
        val archTypesSubdirs = jniLibsForDesktopDir.listFiles() ?: emptyArray()
        for (dir in archTypesSubdirs) {
            // Selecting the proper JNI lib file for run the unit tests
            // in according to the architecture. e.g.: darwin-aarch64, darwin-x86-64
            val arch = System.getProperty("os.arch").replace("_", "-")
            if (dir.isDirectory && dir.name.contains(arch)) {
                systemProperty("java.library.path", dir.absolutePath)
                break
            }
        }
    }
}